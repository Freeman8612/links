<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>font_bitmap</title>
</head>
<style>
    #canvas1, #canvas2, #canvas3 {
        border: 1px solid red;
    }
</style>
<body>
    <h1>Font bitmap generater</h1>
    <hr>
    <div id="list">
        <!-- <p>
           <span style="margin-right: 8px;">1</span> <input placeholder="start point"> - <input placeholder="end point">
        </p> -->
    </div>

    <div>
    <button id="btn_add">+</button>
    <button id="btn_generate">generate</button>
    </div>

    <hr>
    
    <!-- 离屏幕canvas，负责获取点阵数据，显示出来没意义 -->
    <canvas id="canvas1" style="display: block;" width="12" height="12"></canvas>
    <!-- 绘制生成点阵数据的结果，用于预览 -->
    <p>横置横排绘制预览(直取计算后):</p>
    <canvas id="canvas2" height="500px" width="500px"></canvas>
    <!-- 绘制竖直横排数据，用于预览 -->
    <p>竖置横排绘制预览(转换后为LCD所用):</p>
    <canvas id="canvas3" height="500px" width="500px"></canvas>
</body>
<script>
const canvas1 = document.getElementById("canvas1");
const ctx1 = canvas1.getContext("2d", { willReadFrequently: true });
const canvas2 = document.getElementById("canvas2");
const ctx2 = canvas2.getContext("2d", { willReadFrequently: true });
const canvas3 = document.getElementById("canvas3");
const ctx3 = canvas3.getContext("2d", { willReadFrequently: true });
const btn_add = document.getElementById("btn_add");
const btn_generate = document.getElementById("btn_generate");
const list = document.getElementById("list");

let INDEX = 1;
let PREV_LEN = 0;

btn_add.addEventListener("click", addItem);
btn_generate.addEventListener("click", generate);

addItem();

async function generate ()
{
    set_disabled(true);

    let ok = true;
    const tuple = [];

    if ([...list.children].length === 0)
    {
        alert("The list is empty!");
        set_disabled(false);
        return;
    }

    [...list.children].forEach((it, i) => {
        if(it.getAttribute("data-index") === null) return;
        const arr = [];
        [...it.children].forEach((it1, i1) => {
            if (it1.tagName !== "INPUT") return;
            const v = it1.value;
            console.warn("vvvv", v);
            if (isNaN(v) || v === "") {
                alert(`${i + 1}, ${arr.length == 0 ? "start point" : arr.length == 1 ? "end point" : arr.length == 2 ? "size" : ""} invalidate!`);
                ok = false;
            }
            arr.push(Number(v));
        });
        tuple.push(arr);
    });

    if (!ok) {
        set_disabled(false);
        return;
    }

   
    const h6 = list.getElementsByTagName("h6")[0];
    if (h6) list.removeChild(h6);

    PREV_LEN = 0;


    let s = ``;

    for (let i = 0; i < tuple.length; i++)
    {
        const arr = tuple[i];
        console.log(arr);
        const [byte_len, data] = await generateCoderRangeData(...arr, rate => {
            list.children[i].lastChild.innerHTML = rate;
        });
        list.children[i].lastChild.innerHTML = `byte size: ${byte_len}, start_addr: ${PREV_LEN}`;

        s += `\n\n\n#start_addr: ${PREV_LEN}, size: ${byte_len}byte\n` + data;
        PREV_LEN += byte_len;

    }

    const p = document.createElement("h6");
    p.innerHTML = `total size: ${PREV_LEN} byte`;
    list.appendChild(p);

    set_disabled(false);

    const file = new File([s], "");
    const a = document.createElement("a");
    a.setAttribute("download", "font_bitmap.ffbf");
    a.href = URL.createObjectURL(file);
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    document.body.removeChild(a);
}

function set_disabled (is = true)
{
    [...list.children].forEach(it => {
        [...it.children].forEach(it1 => {
            if (it1.tagName == "INPUT" || it1.tagName == "BUTTON") {
                if (is) it1.setAttribute("disabled", is);
                else it1.removeAttribute("disabled");
            }
        });
    });
    if (is) {
        btn_add.setAttribute("disabled", true);
        btn_generate.setAttribute("disabled", true);
    } else {
        btn_add.removeAttribute("disabled");
        btn_generate.removeAttribute("disabled");
    }
}

function onItemDelete (index, item)
{
    list.removeChild(item);
    resetIndex();
}

function resetIndex ()
{
    INDEX = 1;
    const items = list.children;
    [...items].forEach(it => {
        it.firstChild.innerHTML = INDEX++;
    });
}

function addItem ()
{
    const item = createItem(INDEX++);
    list.appendChild(item);
}

// 创建item
function createItem (index)
{
    const p = document.createElement("p");
    const span = document.createElement("span");
    const inp1 = document.createElement("input");
    const inp2 = document.createElement("input");
    const inp3 = document.createElement("input");
    const sep = document.createTextNode(" - ");
    const del = document.createElement("button");
    const progress = document.createElement("span");

    p.appendChild(span);
    span.style = `width: 32px; display: inline-block;`;
    p.setAttribute("data-index", index);
    span.innerText = index;
    p.appendChild(inp1);
    p.appendChild(sep);
    p.appendChild(inp2);
    inp1.setAttribute("placeholder", "start point");
    inp2.setAttribute("placeholder", "end point");
    inp3.setAttribute("placeholder", "size");
    inp3.value = 12;
    inp3.style = `margin-left: 16px; display: inline-block; width: 32px;`;
    p.appendChild(inp3);
    p.appendChild(del);
    del.innerHTML = "delete";
    del.style = `margin-left: 8px;`;
    del.onclick = onItemDelete.bind(null, index, p);
    p.appendChild(progress);
    progress.setAttribute("id", "rate");

    return p;
}



async function generateCoderRangeData (start_point, end_point, size, progress_cb = () => {})
{

    const start_offset = start_point;
    const range = end_point - start_point + 1;
    let byte_count = 0;
    let str = `W${size},H${size},S${start_point},E${end_point}\n`;

    while (true) {
        if (start_point > end_point) break;

        const word = String.fromCodePoint(start_point);
        console.log(word);
        const data = generateFontData(word, size);
        ctx2.clearRect(0, 0, 500, 500);
        drawGridFont(data, size);
        drawGrid(ctx2, size);

        function drawUnicodePoint () {
            ctx2.save();
            ctx2.font = "18px 黑体";
            ctx2.fillText("0x" + start_point.toString(16), 20, 20);
            ctx2.restore();
        }
        drawUnicodePoint();

        const [LCDData, left_space, right_space] = toLCDFontBytes(data, size, true);
        ctx3.clearRect(0, 0, 500, 500);
        drawLCDFontBytes(ctx3, LCDData, size);
        drawGrid(ctx3, size);

        str += `${(left_space << 4) | (right_space & 0x0f)},${LCDData.join(",")}\n`;
        byte_count += (1 + LCDData.length);

        const rate = (Number( ((start_point - start_offset) / range).toFixed(2) ) * 100) | 0;
        setTimeout(() => progress_cb(rate + "% "), 0);

        await new Promise(r => setTimeout(r, 1));
        start_point++;
    }
    
    return [byte_count, str];
}

/* 利用ctx1获得点阵数据，返回恒指横排的字节流 */ 
function generateFontData (word = "黎", blockCount = 16) {
    ctx1.save();

    if (generateFontData.size != blockCount) {
        canvas1.setAttribute("height", blockCount);
        canvas1.setAttribute("width", blockCount);
        generateFontData.size = blockCount;
    }

    ctx1.clearRect(0, 0, blockCount, blockCount);
    ctx1.font = `${blockCount}px SimSun`;
    ctx1.fillStyle = "black";
    ctx1.textAlign = "center";
    ctx1.textBaseline = "middle"
    ctx1.fillText(word, blockCount / 2, blockCount / 2);

    /* 宽度检测(用于不定款字体测量) */
    /*
    let start_p = -1, end_p = -1;
    for (let i = 0; i < blockCount; i++) {
        if (start_p === -1) {
            const d = ctx1.getImageData(i, 0, 1, blockCount, { colorSpace: "srgb" });
            for (let j = 0; j < blockCount; j++) {
                if (d.data[j * 4 + 3] > 0) {
                    start_p = i;
                    break;
                }
            }
        }
        if (end_p === -1) {
            const d = ctx1.getImageData(blockCount - 1 - i, 0, 1, blockCount, { colorSpace: "srgb" });
            for (let j = 0; j < blockCount; j++) {
                if (d.data[j * 4 + 3] > 0) {
                    end_p = blockCount - i - 1;
                    break;
                }
            }
        }
        if (start_p !== -1 && end_p !== -1) break;
    }
    console.log(start_p + " <-> " + end_p);
    */

    const res = [];
    const s = ctx1.getImageData(0, 0, blockCount, blockCount, { colorSpace: "srgb" });
    // console.log(s);

    for (let i = 0; i < blockCount * blockCount; i++) {
        const ss = s.data.slice(i * 4, i * 4 + 4);
        res.push(ss[3] > 0 && ss[0] == 0 && ss[1] == 0 && ss[2] == 0 ? 1 : 0);
    }

    ctx1.restore();
    // console.log(res);
    return res;
}
generateFontData.size = 12;

/* 将横置横排的点阵数据会知道ctx2（canvas2） */ 
function drawGridFont (pixelBlocks = [], count = 16) {
    ctx2.save();

    const step = Math.ceil(400 / count);

    for (let y = 0; y < count; y++) {
        for (let x = 0; x < count; x++) {
            block = pixelBlocks[y * count + x];
            // console.log(block);
            ctx2.fillStyle = block ? "black" : "white";
            ctx2.fillRect(50 + (x * step), 50 + (y * step), step, step);
        }
    }

    ctx2.restore();
}

/* 绘制点阵网格（方便直观调试） */ 
function drawGrid (ctx, count = 16) {
    ctx.save();

    let x = 50, y = 50;
    const step = Math.ceil(400 / count);
    ctx.fillStyle = "red";
    for (let i = 0; i <= count; i++)
    {
        ctx.fillRect(x, 50, 1, count * step);
        ctx.fillRect(50, y, count * step, 1);
        x += step;
        y += step;
    }

    ctx.restore();
}

/* 横置横排转竖置横排 */
function toLCDFontBytes (points = [], size = 16)
{   
    let start_p = -1, end_p = -1;
    /* 不定宽字体的宽度获取 */
    for (let col = 0; col < size; col++) {
        if (start_p === -1) {
            for (let i = 0; i < size; i++) {
                if (points[i * size + col] > 0) start_p = col;
            }
        }
        if (end_p === -1) {
            for (let i = 0; i < size; i++) {
                if (points[i * size + (size - col - 1)] > 0) end_p = size - col - 1;
            }
        }
        if (start_p != -1 && end_p != -1) break;
    }

    console.log("start_p: ", start_p, "end_p: ", end_p, "width: ", end_p - start_p + 1);

    const left_space = start_p < 0 ? 0 : start_p;
    const right_space = end_p < 0 ? 0 : (size - 1) - end_p - 1/*这个减去1是右侧故意多留一个空格*/;
  
    const res = new Array( Math.ceil(size / 8)/*垂直多少个8bit*/ * size).fill(0);

    for (let i = 0; i < size; i++) { // 每个垂直像素行
        for (let j = 0; j < size; j++) { // 每个水平像素点
            const color = points[i * size/* 使用原来的宽度 */ + j];
            const res_row = (i / 8) | 0;
            const res_pos = res_row * size + j;
            res[res_pos] |= (color << (i % 8));
        }
    }
    // console.log("fuck: ", res);

    return [res, left_space, right_space];
}

/* 绘制LCD横置横排数据 */
function drawLCDFontBytes (ctx = null, bytes = [], size = 16) {
    ctx.save();

    const step = Math.ceil(400 / size);

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const byte_pos = ( ((y / 8) | 0) * size ) + x;
            const bit_left_step = y % 8;
            
            ctx.fillStyle = (bytes[byte_pos] & (1 << bit_left_step)) ? "black" : "white";
            ctx.fillRect(50 + (x * step), 50 + (y * step), step, step);
        }
    }

    ctx.restore();
}
</script>
</html>